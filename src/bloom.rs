use crate::fnv::Fnv1Hasher;
use std::io::{self, BufWriter, Read, Write};
use thiserror::Error;

// this is the largest prime number < 2^64. As we will probably never encounter
// a Bloom filter with a number of bits > m (if yes sorry to you people from,
// the future, I envy your available RAM though) we can use the pseudorandom
// sequence generated by repeatedly multiplying the initial hash value h
// with g and taking the modulo over m to generate a sequence of hash values
// that has a uniform distribution.
const M: u64 = 18446744073709551557;

// this is our multiplier. It has a very large primitive root
// so that it will not repeat a given cycle for any practically meaningful
// value of k.
const G: u64 = 18446744073709550147;

pub struct Fingerprint {
    hn: u64,
    m: u64,
    i: u64,
    size: u64,
}

impl Fingerprint {
    #[inline(always)]
    pub fn with_size<H: std::hash::Hasher + Default>(data: &[u8], modulo: u64, size: u64) -> Self {
        let mut hasher: H = H::default();
        hasher.write(data);
        Self {
            hn: hasher.finish(),
            m: modulo,
            i: 0,
            size,
        }
    }
}

impl Iterator for Fingerprint {
    type Item = u64;
    #[inline(always)]
    fn next(&mut self) -> Option<Self::Item> {
        if self.i < self.size {
            self.hn = self.hn.wrapping_mul(G);
            self.hn %= M;
            self.i = self.i.wrapping_add(1);
            return Some(self.hn % self.m);
        }
        None
    }
}

fn read_le_u64<R: Read>(r: &mut R) -> Result<u64, io::Error> {
    let mut bytes = [0u8; 8];
    r.read_exact(bytes.as_mut_slice())?;
    Ok(u64::from_le_bytes(bytes))
}

fn read_le_f64<R: Read>(r: &mut R) -> Result<f64, io::Error> {
    let mut bytes = [0u8; 8];
    r.read_exact(bytes.as_mut_slice())?;
    Ok(f64::from_le_bytes(bytes))
}

#[derive(Debug, Error)]
pub enum Error {
    #[error("{0}")]
    IoError(#[from] io::Error),
    #[error("invalid version {0}")]
    InvalidVersion(u64),
    #[error("union error: {0}")]
    Union(String),
    #[error("too many entries, false positive rate cannot be met")]
    TooManyEntries,
}

#[allow(non_snake_case)]
#[derive(Debug, Default, Clone)]
pub struct BloomFilter {
    // M == bitset.len()
    bitset: Vec<u64>,
    // n: desired maximum number of elements
    cap: u64,
    // desired false positive probability
    p: f64,
    // k: number of hash functions
    n_hash: u64,
    // m: number of bits
    bit_size: u64,
    // N: number of elements in the filter
    count: u64,
    // arbitrary data that we can attach to the filter
    pub data: Vec<u8>,
}

impl BloomFilter {
    #[inline(always)]
    fn fingerprint<S: AsRef<[u8]>>(&self, value: S) -> Fingerprint {
        Fingerprint::with_size::<Fnv1Hasher>(value.as_ref(), self.bit_size, self.n_hash)
    }

    pub fn with_capacity(cap: u64, proba: f64) -> Self {
        // size in bits, computed from the capacity we want and the probability
        let bit_size = f64::abs(f64::ceil(
            (cap as f64) * f64::ln(proba) / f64::ln(2.0).powf(2.0),
        ));

        // size in u64
        let u64_size = f64::ceil(bit_size / 64.0) as usize;
        let n_hash_fn = f64::ceil(f64::ln(2.0) * bit_size / (cap as f64)) as u64;

        Self {
            bitset: vec![0; u64_size],
            cap,
            p: proba,
            n_hash: n_hash_fn,
            bit_size: bit_size as u64,
            count: 0,
            data: vec![],
        }
    }

    #[inline(always)]
    pub fn cap(&self) -> usize {
        self.cap as usize
    }

    #[inline(always)]
    pub fn proba(&self) -> f64 {
        self.p
    }

    #[inline(always)]
    pub fn n_hash_fn(&self) -> u64 {
        self.n_hash
    }

    #[inline(always)]
    pub fn n_bits(&self) -> u64 {
        self.bit_size
    }

    #[inline]
    pub fn from_reader<R: Read>(r: R) -> Result<Self, Error> {
        let mut r = io::BufReader::new(r);

        let flags = read_le_u64(&mut r)?;
        let mut b = Self::default();

        let version = flags & 0xff;

        if version != 1 {
            return Err(Error::InvalidVersion(version));
        }

        b.cap = read_le_u64(&mut r)?;
        b.p = read_le_f64(&mut r)?;
        b.n_hash = read_le_u64(&mut r)?;
        b.bit_size = read_le_u64(&mut r)?;
        b.count = read_le_u64(&mut r)?;

        // initializing bitset
        let u64_size = f64::ceil((b.bit_size as f64) / 64.0) as u64;
        b.bitset = vec![0; u64_size as usize];

        // reading the bloom filter
        for i in b.bitset.iter_mut() {
            *i = read_le_u64(&mut r)?;
        }

        // reading data
        b.data = std::io::read_to_string(r)?.as_bytes().to_vec();

        Ok(b)
    }

    #[inline]
    pub fn write<W: Write>(&self, w: &mut W) -> Result<(), Error> {
        let mut w = BufWriter::new(w);

        w.write_all(&1u64.to_le_bytes())?;
        w.write_all(&self.cap.to_le_bytes())?;
        w.write_all(&self.p.to_le_bytes())?;
        w.write_all(&self.n_hash.to_le_bytes())?;
        w.write_all(&self.bit_size.to_le_bytes())?;
        w.write_all(&self.count.to_le_bytes())?;

        for i in self.bitset.iter() {
            w.write_all(&i.to_le_bytes())?;
        }

        w.write_all(&self.data)?;
        Ok(())
    }

    #[inline(always)]
    /// get the nth bit value
    fn get_nth_bit(&self, index: u64) -> bool {
        let iblock = index / 64;
        let ibit = index % 64;
        // we cannot overflow shift as ibit < 64
        let bit = 1u64.wrapping_shl(ibit as u32);
        self.bitset[iblock as usize] & bit == bit
    }

    pub fn bits(&self) -> Vec<bool> {
        (0..self.bit_size)
            .map(|i| self.get_nth_bit(i))
            .collect::<Vec<bool>>()
    }

    /// inserts a value into the bloom filter, as bloom filters are not easily
    /// growable an error is returned if we try to insert too many entries
    #[inline(always)]
    pub fn insert<S: AsRef<[u8]>>(&mut self, value: S) -> Result<(), Error> {
        let mut new = false;

        for index in self.fingerprint(value) {
            let iblock = index / 64;
            let ibit = index % 64;

            let entry = self
                .bitset
                .get_mut(iblock as usize)
                .expect("block index out of bound");

            // we cannot overflow shift as ibit < 64
            let bit = 1u64.wrapping_shl(ibit as u32);

            // this is the old bit value
            let old = *entry & bit == bit;
            if !old && self.count >= self.cap {
                return Err(Error::TooManyEntries);
            }

            // we update entry
            *entry |= bit;

            if !old {
                new = true
            }

            debug_assert!(self.get_nth_bit(index))
        }

        if new {
            self.count += 1;
        }

        Ok(())
    }

    #[inline(always)]
    pub fn insert_unchecked<S: AsRef<[u8]>>(&mut self, value: S) {
        let _ = self.insert(value);
    }

    /// clears out the bloom filter
    #[inline(always)]
    pub fn clear(&mut self) {
        self.bitset.iter_mut().for_each(|bucket| *bucket = 0);
        self.count = 0;
    }

    /// checks if an entry is contained in the bloom filter
    #[inline(always)]
    pub fn contains<S: AsRef<[u8]>>(&self, value: S) -> bool {
        for index in self.fingerprint(value) {
            if !self.get_nth_bit(index) {
                return false;
            }
        }
        true
    }

    /// counts all the set bits in the bloom filter
    #[inline(always)]
    pub fn count_ones(&self) -> usize {
        self.bitset.iter().map(|u| u.count_ones() as usize).sum()
    }

    /// counts all the unset bits in the bloom filter
    #[inline(always)]
    pub fn count_zeros(&self) -> usize {
        self.bitset.iter().map(|u| u.count_zeros() as usize).sum()
    }

    /// function used to update the estimated count of entries
    fn update_count(&mut self) {
        self.count = (-(self.bit_size as f64
            * f64::ln(1.0 - (self.count_ones() as f64 / self.bit_size as f64)))
            / self.n_hash as f64) as u64;
    }

    /// returns an estimate of the number of element in the filter
    /// the exact number of element cannot be known as there might
    /// be collisions
    #[inline(always)]
    pub fn count_estimate(&self) -> u64 {
        self.count
    }

    #[inline(always)]
    pub fn size_in_u64(&self) -> usize {
        self.bitset.len()
    }

    #[inline(always)]
    pub fn size_in_bytes(&self) -> usize {
        self.bitset.len() * core::mem::size_of::<u64>()
    }

    #[inline(always)]
    pub fn has_same_params(&self, other: &Self) -> bool {
        self.cap == other.cap
            && self.p == other.p
            && self.n_hash == other.n_hash
            && self.bit_size == other.bit_size
            && self.bitset.len() == other.bitset.len()
    }

    /// makes the union of self with another bloom filter (having the same
    /// parameters)
    #[inline]
    pub fn union(&mut self, other: &Self) -> Result<(), Error> {
        if !self.has_same_params(other) {
            return Err(Error::Union(
                "cannot make union of bloom filters with different parameters".into(),
            ));
        }

        for (i, e) in self.bitset.iter_mut().enumerate() {
            *e |= other.bitset[i];
        }

        // we need to update the estimated number of elements after a union
        self.update_count();

        Ok(())
    }
}

/// macro to ease bloom filter creation
/// # Example
/// ```
/// use poppy::bloom;
///
/// let mut b = bloom!(100, 0.1);
/// b.insert("hello");
/// assert!(b.contains("hello"));
/// ```
///
/// # Other Example
/// ```
/// use poppy::bloom;
///
/// let mut b = bloom!(100, 0.1, ["hello", "world"]);
/// assert!(b.contains("hello"));
/// assert!(b.contains("world"));
/// ```
#[macro_export]
macro_rules! bloom {
        ($cap:expr, $proba:expr) => {
            $crate::BloomFilter::with_capacity($cap, $proba)
        };
        ($cap:expr, $proba:expr, [$($values:literal),*]) => {
            {
                let mut b=bloom!($cap, $proba);
                $(b.insert($values).unwrap();)*
                b
            }
        };
    }

#[cfg(test)]
mod tests {
    use std::io;

    use super::*;

    #[test]
    fn test_bloom() {
        let mut b = BloomFilter::with_capacity(100000, 0.001);
        assert!(!b.contains("value"));
        b.insert_unchecked("value");
        assert!(b.contains("value"));
        assert_eq!(b.count, 1);
        assert!(!b.contains("unknown"));
    }

    #[test]
    fn test_macro() {
        let b = bloom!(1000, 0.0001, ["hello", "world"]);
        assert!(b.contains("hello"));
        assert!(b.contains("world"));
    }

    #[test]
    fn test_serialization() {
        let b = bloom!(1000, 0.0001, ["deserialization", "test"]);
        let mut cursor = io::Cursor::new(vec![]);
        b.write(&mut cursor).unwrap();
        cursor.set_position(0);
        // deserializing the stuff out
        let b = BloomFilter::from_reader(cursor).unwrap();
        assert_eq!(b.proba(), 0.0001);
        assert!(b.contains("deserialization"));
        assert!(b.contains("test"));
        assert!(!b.contains("hello"));
        assert!(!b.contains("world"));
    }

    #[test]
    fn test_deserialization() {
        // this test file has been generated with Go bloom cli
        let data = include_bytes!("./data/test.bloom");
        let pb = bloom!(10000, 0.01);
        let b = BloomFilter::from_reader(io::BufReader::new(io::Cursor::new(data))).unwrap();
        // proba it's been serialzed with with Go implementation
        assert!(pb.has_same_params(&b));
        assert!(b.contains("hello"));
        assert!(b.contains("world"));
        assert!(!b.contains("hello world"));
    }

    #[test]
    fn test_union() {
        let mut b = bloom!(1000, 0.0001, ["hello", "world"]);
        let o = bloom!(1000, 0.0001, ["union", "test"]);

        b.union(&o).unwrap();

        ["hello", "world", "union", "test"]
            .into_iter()
            .for_each(|v| {
                assert!(b.contains(v));
            });

        // estimate count should be exact for a small test like this
        assert_eq!(b.count_estimate(), 4);
    }

    #[test]
    fn test_union_failure() {
        let mut b = bloom!(1000, 0.0001, ["hello", "world"]);
        let o = bloom!(100, 0.0001, ["union", "test"]);

        assert!(b.union(&o).is_err())
    }

    #[test]
    fn test_clear() {
        let mut b = bloom!(1000, 0.0001, ["hello", "world"]);

        assert_eq!(b.count_estimate(), 2);
        b.clear();
        assert!(!b.contains("hello"));
        assert!(!b.contains("world"));
        assert_eq!(b.count_estimate(), 0);
    }

    #[test]
    fn test_too_many_entries() {
        let mut b = bloom!(5, 0.0001, ["hello", "world", "toasting", "bloom", "filter"]);

        assert_eq!(b.count_estimate(), 5);
        assert!(matches!(
            b.insert("everything should explode, OMG !"),
            Err(Error::TooManyEntries)
        ));
    }
}
