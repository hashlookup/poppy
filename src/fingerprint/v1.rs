use std::hash::Hasher;

use crate::fnv::Fnv1Hasher;

use super::Fingerprinter;

// this is the largest prime number < 2^64. As we will probably never encounter
// a Bloom filter with a number of bits > m (if yes sorry to you people from,
// the future, I envy your available RAM though) we can use the pseudorandom
// sequence generated by repeatedly multiplying the initial hash value h
// with g and taking the modulo over m to generate a sequence of hash values
// that has a uniform distribution.
const M: u64 = 18446744073709551557;

// this is our multiplier. It has a very large primitive root
// so that it will not repeat a given cycle for any practically meaningful
// value of k.
const G: u64 = 18446744073709550147;

#[derive(Debug, Default, Clone, Copy)]
pub struct Fingerprint {
    h: u64,
    m: u64,
    i: u64,
    count: u64,
}

impl Fingerprinter for Fingerprint {
    fn new(count: u64, modulo: u64) -> Self {
        Self {
            m: modulo,
            count,
            ..Default::default()
        }
    }

    #[inline(always)]
    fn fingerprint<S: AsRef<[u8]>>(mut self, data: S) -> Self {
        let mut hasher = Fnv1Hasher::default();
        hasher.write(data.as_ref());
        self.h = hasher.finish() % M;
        self.i = 0;
        self
    }
}

impl Iterator for Fingerprint {
    type Item = u64;

    fn next(&mut self) -> Option<Self::Item> {
        if self.i < self.count {
            self.h = self.h.wrapping_mul(G) % M;
            self.i = self.i.wrapping_add(1);
            return Some(self.h % self.m);
        }
        None
    }
}
